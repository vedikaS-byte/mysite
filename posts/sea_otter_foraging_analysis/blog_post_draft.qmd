---
title: ""
format: html
---

# Assessing Sea Otter Feeding Habitats Based on Prey Type and Dive Depth

### **Purpose**

The sea otter (*Enhydra lutris)* is a highly social marine mammal that plays a vital role as a keystone species in maintaining the health of kelp forest ecosystems by keeping sea urchin populations in check. While sea otters are primary predators of sea urchins, their diets are shown to be varied. For example, sea otters are known to eat (SOURCE). Sea urchins. Because of their important role as a keystone species, understanding their diet and foraging patterns is essential for assessing feeding preferences and food availability in conservation. \[ADD DISTRIBUTION\].

This blog post aims to present and discuss the results of a statistical regression analysis conducted on sea otter foraging data collected from visual observations in Prince of Wales, Alaska, by LaRoche et al. (2018). A beta regression using `betareg` with a zero-adjustment was selected for the analysis in order to assess the proportion of prey not consumed by sea otters during summer 2018. The age (adult and juvenile) of observed sea otters were considered as a potential confounding variables impacting diving time, preference for prey, and the proportion of prey left uneaten. The following question was utilized to guide the analysis:

**How does prey categorization and dive depth predict the proportion of prey not eaten?**

The mean proportion not eaten was modeled using a Beta regression with a logit link, while a precision parameter (φ) captured the variability in proportions around the mean.

-   **Hypothesis 1:**

    -   H~0~: β~prey_cat_urchins~ = 0. Sea otters leave the same proportin of urchins uneaten as they do clams; prey category does not influence the proportion of prey eaten.

    -   HA: β~prey_cat_urchins~ ≠ 0. Sea otters leave a significantly different proportion of urchins uneaten compared to clams; prey category has a significant effect on the proportion of prey not eaten.

-   **Hypothesis 2**:

    -   H0: β~dive_time~ = 0. Dive time has no significant effect on the proportion of prey not eaten; the duration of a dive does not influence how much prey is not eaten.

    -   HA: β~dive_time~ ≠ 0. Dive time does significantly affect the proportion of prey not eaten; longer or shorter dives are associated with a higher or lower proportion of prey left uneaten.

-   The blog post provides context and background for the question

-   The data are explained using text and figures

-   The relationships and causal relationships are described with a DAG

### Data Importation, Exploration, and Cleaning

This project uses \[VARIABLES\]:

-   

-   

```{r}
#| output: false
library(here)
library(tidyverse)
library(betareg) # https://cran.r-project.org/web/packages/betareg/vignettes/betareg.html#sec-model
library(broom)         
library(broom.mixed)   # tidy() for glmmTMB
library(kableExtra)
```

```{r}
#| output: false
set.seed(123)
forage <- read_csv("forage_final (1).csv")
```

```{r}
# Structure
str(forage)
```

```{r}
## drop NAs
colSums(is.na(forage))
```

```{r}
# Select for just prey category, diving time, and prey handling time 
# table(forage$age)
# table(forage$sex)
forage <- forage %>% select(BoutID, PreyCat, PreyItem, DT, HT,PropNotEat, age)
forage <- forage %>% filter(age != "U") 
forage <- forage %>% drop_na()

dim(forage)
```

```{r}
# Check the colSums... were they all dropped?
colSums(is.na(forage)) 
```

```{r}
# Create a scatterplot of dive time related to the proportion of prey not eaten based on prey category
forage %>% ggplot(aes(x = DT, y = PropNotEat))+ geom_jitter() + theme_bw() +  #+ scale_color_discrete(palette = "Set2") + 
#   #facet_wrap(~PreyCat, scale = "free") + 
  #theme(legend.position = "none") + 
labs(x = "Diving Time (seconds)", y = "Proportion of Prey Not Eaten", 
                                               title = "Proportion of Prey Not Consumed By Sea Otters Based on Diving Time") + theme(plot.title = element_text(size = 11, face = "bold"))

# Create boxplots to visualize the distribution of prey categories and proportion of prey not eaten
forage %>% ggplot(aes(x = PreyCat, y = PropNotEat, fill = PreyCat)) + geom_boxplot() + theme_bw()
```

### **Statistical model**

\[stat notation\]

Here, simulated data was generated to

`betareg(formula, data, subset, na.action, weights, offset, link = "logit", link.phi = NULL, control = betareg.control(...), model = TRUE, y = TRUE, x = FALSE, ...)`

```{r}
# Beta does not take direct 0 and 1! need to do adjustment to offset before 1 and after 0 ()
forage <- forage %>%
  mutate(PropNotEat_adj = # Transformation to adjust (betareg cranr)
           (PropNotEat * (nrow(.) - 1) + 0.5) / nrow(.))
```

```{r}
# Model with interaction
forage_beta <- glmmTMB(
  PropNotEat_adj ~ DT + PreyCat,
  data = forage,
  family = beta_family(link = "logit")
)

# Model interaction with age
forage_interaction_with_age <- forage_org <- glmmTMB(
  PropNotEat_adj ~ PreyCat * DT + age,
  data = forage,
  family = beta_family(link = "logit")
)

# Model with interaction
forage_interaction <- betareg(PropNotEat_adj ~ PreyCat * DT, data = forage)

# Model with interaction
forage_interaction_age <- betareg(PropNotEat_adj ~ PreyCat + DT*age, data = forage)
summary(forage_interaction_age)

# Control variable/additional variable inclusion beta regression
forage_beta <- betareg(PropNotEat_adj ~ PreyCat + DT + age, data = forage)
summary(forage_beta)
forage$PropNotEat_adj
forage_org <- betareg(PropNotEat_adj ~ PreyCat + DT, data = forage)


#summary(forage_interaction)

# Compare models (lowest AIC) (Akaike's An Information Criterion for log-link)

AIC(forage_interaction_added, forage_interaction, forage_interaction_age, forage_beta, forage_org)
```

-   The statistical model is explained conceptually and using formal statistical notation

-   The blog post demonstrates how to simulate data according to model assumptions

<!-- -->

-   The blog post demonstrates that a model fit to the simulated data recovers the parameters

```{r}
# Build prediction grid
predicted_data <- expand.grid(
  # Establish 
  DT = seq(min(forage$DT, na.rm = TRUE), max(forage$DT, na.rm = TRUE), length.out = 100),
  PreyCat = levels(factor(forage$PreyCat))
)

# 2. Match factor levels
predicted_data_all$PreyCat <- factor(predicted_data_all$PreyCat, levels = levels(factor(forage$PreyCat)))

# 3. Predict with glmmTMB
predicted_data_all$predicted_prop_not_eaten <- predict(
  forage_org, 
  newdata = predicted_data_all,
  type = "response"
)

# 4. Plot fitted lines
ggplot(predicted_data_all, aes(x = DT, y = predicted_prop_not_eaten, color = PreyCat)) +
  geom_line(size = 1) +
  labs(
    title = "Predicted Proportion Not Eaten vs Dive Time by Prey Category",
    x = "Dive Time (DT)",
    y = "Predicted Proportion Not Eaten"
  ) +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")

```

```{r}
# Reset seed (redefined)
set.seed(123)

# Define simulated obs... with law of large numbers, larger sample size should get closer to actual predictors
n_sim <- 15000

# Define coefficients from original model
beta0 <- 0.661699 
beta_dive_time <- -0.004531 
beta_crab <- -0.280233
beta_cucumber <- -0.411384
beta_star <- -0.014340
beta_urchin <- -0.184979
phi <- 1.787047 # Precision

## Simulate range for predictors
dt <- runif(n_sim, 3, 255) # Range of dive time

# Randomly generate PreyCat factors for simulated data... then for each level, sample with replacement to get vector of length n_sim
PreyCat <- sample(c("Clam","Crab","Cucumber","Star","Urchin"), n_sim, replace = TRUE)

## Define linear predictor and logit equation
# Assign coefficient to each PreyCat level
prey_effect <- ifelse(PreyCat == "Crab", beta_crab,
               ifelse(PreyCat == "Cucumber", beta_cucumber,
               ifelse(PreyCat == "Star", beta_star,
               ifelse(PreyCat == "Urchin", beta_urchin, 
               0)))) # Else assign clam (reference)

glm_eq <- beta0 + beta_dive_time * dt + prey_effect # Recall that prey_effect has the associated beta coefficient for each level

# Convert linear predictor (logit scale) to  mean proportion on  response scale
mean_sim <- exp(glm_eq) / (1 + exp(glm_eq))

# Reparameterize beta distribution parameters (derived from CRAN at (https://search.r-project.org/CRAN/refmans/betareg/html/dbetar.html)
alpha <- mean_sim * phi
beta <- (1 - mean_sim) * phi

# Simulate response variable from beta distribution using calculated alpha and beta 
PropNotEat_adj <- rbeta(n_sim, alpha, beta)

# Create simulated data frame
simulated_forage <- data.frame(
  PropNotEat_adj = PropNotEat_adj,
  DT = dt,
  PreyCat = factor(PreyCat, levels = c("Clam","Crab","Cucumber","Star","Urchin"))
)

# Fit simulated model
sim_model <- glmmTMB(
  PropNotEat_adj ~ DT + PreyCat,
  data = simulated_forage,
  family = beta_family(link = "logit")
)
summary(sim_model)
summary(forage_org)
```

### **Inference**

```{r}
# # Load necessary packages
# 
# ?tidy()
# # Tidy original model 
# orig_coefs <- broom::tidy(forage_org) %>%
#   select(term, estimate) %>%
#   rename(Estimate_Original = estimate)
# 
# # 2. Tidy the simulated model (glmmTMB)
# sim_coefs <- broom.mixed::tidy(sim_model) %>%
#   filter(effect == "fixed") %>%      # only fixed effects
#   select(term, estimate) %>%
#   rename(Estimate_Simulated = estimate)
# 
# # 3. Combine by term
# coef_table <- full_join(orig_coefs, sim_coefs, by = "term")
# 
# # 4. Display table
# coef_table %>%
#   kable(format = "html", digits = 3, caption = "Comparison of Coefficients: Original vs Simulated") %>%
#   kable_styling(full_width = F, position = "center", bootstrap_options = c("striped", "hover"))

```

-   Hypotheses are stated in plain language and with visualizations

-   Model estimates are presented with appropriate uncertainty (e.g., confidence intervals)

```{r}
## bootstrapping


```

-   A hypothesis is tested and the evidence is interpreted

### **Professionalism**

-   The overall appearance of the blog post (e.g., figures, code outputs) is portfolio-quality

-   The writing is comprehensible to a technical audience

-   The code is well-organized and appropriately documented
